Name: Michael Simpson
Date: 05-21-15
Course: CS322
Instructor: Jones
Assignment: #3


1) For Loop Assembly Code Generation
-------------------------------------------------------------------------------------
    In solving this problem I began by listing out all eight possible combinations
of a valid for loop. I then tried to assign meaning to each of these combinations. 

    For instance, if there was a loop that was missing the initialization portion but 
still included test and step portions the loop should function the same as a for 
loop with all three portions present. Obviously you would have needed to define
and initialize a correlating variable before hand, but that is outside of the scope
of the actual loop. Or if the loop was missing all three portions, it would be
semantically equivalent to a while(1) loop and loop infinitely without the presence
of a reachable break statement.

    Next I looked at the implementation of the compile method for a while statement.
Since the for loop had expressed similar characteristics to a while loop in some 
scenarios, I thought it would be a good place to start.

    I began by inserting a compile function call for the initialization portion before 
performing any emit instructions. My rationale was that you need to initialize the
looping variable prior to executing any of the body or other looping components,
and that you would only ever do this once. I surrounded the compile function with
a test of whether init was null to allow for the possibility of it to be absent.

    Next I left in the emit statments of the initial jump to lab2, (a possible optimization
if you expect the loop to execute more than once), and the target lab1. 

    By following the logic in jumping to lab2, I arrived at the test expression. Here I execute
a branchTrue function call because this expression will alter the control flow of the 
program based on the value of its evaluation. I chose to place this here because it would 
make no sense to enter the body of the loop if the expression evaluates to false. This 
branchTrue statement is also surrounded by an if statement to allow for the expression to 
be absent, but I also included an else branch that would emit a jump to lab1 in the event 
of this absence. I made this choice to preserve the looping behavior.

    If the test expression were to evaluate to true (or there was no test expression), the
program flow will jump to lab1. Here is where I generate the compilation of the loop
body, and then compile the expression of the step expression. The step portion is 
also surrounded by an if statement to allow for its absense. I could have swapped the 
order of the compilations of the body and step, but the flow seemed more natural 
this way.  
     
     // Added to For class in ast/For.java
     public boolean compile(Assembly a, Frame f) {
       // Generate two labels for jump targets
       String lab1 = a.newLabel();
       String lab2 = a.newLabel();
       // Only compile an looping variable initialization if one exists
       if(init != null) {
           init.compileExpr(a,f);
       }
       // Emit a jump to the second label
       a.emit("jmp", lab2);
       // Emit the first label
       a.emitLabel(lab1);
       // The body must always exist, and appear between the looping target labels
       body.compile(a,f);
       // If a step expression exits, compile it
       if(step != null) {
            step.compileExpr(a, f);
       }
       // Emit the second label
       a.emitLabel(lab2);
       /** Only compile and brance on the text conditional expression if one exists
        *  Otherwise, only emit a jump instruction to the first label to ensure that
        *  looping behaviour still occurs regardless of the existance of a conditional
        *  expression
        */
       if( test != null ) {
           test.branchTrue(a,f,lab1); 
       } else {
           a.emit("jmp", lab1);
       }
       return true;
    }

    To test the quality of my code generation scheme, I wrote a small test program that contained
all eight configuration possibilites of a for loop and sucessfully compiled it. I then executed
each function independantly and observed their behavior. All instances of the for loop behaved
as I expected. For instance c(), d(), and h() all printed out a the sequence of integers 0-9.
I was forced to abort the execution of all other functions which either printed out zero, or
incrementing values.

    void main() {
        a();
        b();
        c(); 
        d();
        e();
        f();
        g();
        h();

    }

    void a () { int i; for( ; ; ) { print i; } }

    void b () { int i = 0; for( ; ; i = i + 1) { print i; } }

    void c () { int i = 0; for( ;i< 10; ) { print i; i = i + 1; } }

    void d () { int i = 0; for( ;i < 10; i = i + 1 ) { print i; } }

    void e () { int i; for(i = 0; ; ) { print i; } }

    void f () { int i; for(i = 0; ;i = i + 1 ) { print i; } }

    void g () { int i; for(i = 0; i < 10; ) { print i; } }

    void h() { int i; for(i = 0; i < 10; i = i + 1) { print i; } }

I also examined the assembly output in out.s. Here I include some examples:

      .globl	Xa
    Xa:
        pushq	%rbp
        movq	%rsp, %rbp
        pushq	$0
        jmp	l1                      <--- Init missing as expected
    l0:
        movl	-8(%rbp), %edi      <--- Body with no step 
        call	Xprint               
    l1:
        jmp	l0                      <--- Simple jump, missing test
        movq	%rbp, %rsp
        popq	%rbp
        ret


      .globl	Xc
    Xc:
        pushq	%rbp
        movq	%rsp, %rbp
        movl	$0, %eax            <--- Looks like an init, but is actually
        pushq	%rax                     outside the scope of the loop
        jmp	l5
    l4:
        movl	-8(%rbp), %edi
        call	Xprint
        movl	-8(%rbp), %eax
        movl	$1, %edi            <--- Looks like a step, but is actually
        addl	%edi, %eax               part of the body
        movl	%eax, -8(%rbp)
    l5:
        movl	$10, %eax
        movl	-8(%rbp), %edi
        cmpl	%eax, %edi
        jl	l4                      <--- Test present
        movq	%rbp, %rsp
        popq	%rbp
        ret


      .globl	Xh
    Xh:
        pushq	%rbp
        movq	%rsp, %rbp
        pushq	$0
        movl	$0, %eax
        movl	%eax, -8(%rbp)       <--- Actual init present
        jmp	l15
    l14:
        movl	-8(%rbp), %edi
        call	Xprint
        movl	-8(%rbp), %eax
        movl	$1, %edi
        addl	%edi, %eax           <--- Actual step present
        movl	%eax, -8(%rbp)
    l15:
        movl	$11, %eax
        movl	-8(%rbp), %edi
        cmpl	%eax, %edi
        jl	l14                      <--- Test present
        movq	%rbp, %rsp
        popq	%rbp
        ret


2) Initializing Global Variables
-------------------------------------------------------------------------------------

    The process of generating code to initialize global variables within a global
initializaton function was somewhat more difficult for me to wrap my head around.
None the less, I started approaching the problem by following the advice in the 
assignment spec and examined the comiple() method in ast/Defn.java and the 
compileFunction() method in ast/Function.java. 

    From examining the compile() method, I observed code that generated global declarations,
and function definitions. The global declarations were generated via looping through
the defns array and calling compile globals on each element. The same pattern was
done to compile functions using the same defns array. Inspecting further, I discovered
that both the Function and Globals class were inherited from the Defn class, and that
declareGlobals and compileFunction were abstract methods of the Defn class. In the 
Function class, the declareGlobals was a noop and in Globals compileFuncion was a 
noop. This was how the two loops were able to iterate over the same array while acting
purely independantly of one another.

    This is where I began developing the intition to extend the Defn class by another 
abstract definition called compileGlobals. I would put the implementation of this
method in the Globals class because I wanted to work with Global variables, and a noop 
version of the method would reside in the Function class. I would however borrow some 
pattern influence from the compileFuncion since eventually I wanted to produce a global 
function that would execute with the desired semantics.

    /** Generate compiled code for initializing globals
     *  This method is part of the Defn class in ast/Defn.java
     */
    abstract void compileGlobals(Assembly a, LocEnv globals);

    I created a new function initGlobals in the Defn class within ast/Defn.java. I call this 
function in the compile() method within the same class between the emit(".text") instruction,
and the for loop for compiling functions. I placed it after the emit, because I wanted to
generate a function and that is where other functions were being generated. I placed it
before the compileFunctions loop because I wanted it to be the first generated function.
It was notentirely necessary to create a new function for these purposes, but it kept the 
compile function cleaner. 

    /** This method is part of the Defn class in ast/Defn.java
     */
    private static void initGlobals(Assembly a, LocEnv globals, Defn[] defns) {
        // following the pattern to generate code for a function
        a.emit();
        a.emit(".globl", a.name("initGlobals"));
        a.emitLabel(a.name("initGlobals"));
        a.emitPrologue(); 

        /** Loop through the set of top level definitions, compile the
         *  initialization expressions and store their values in a funciton frame
         */
        for ( int i = 0; i < defns.length; ++i) {
            defns[i].compileGlobals(a, globals);
        }

        a.emitEpilogue();
    }

    Within the Globals class there is a type, and an array of VarIntro objects. I 
needed to focus on the array because ultimately that is how I would be able to retrieve 
the value of the initialization expressions. I implemented the function compileGlobals within
the Globals class, and it begins by retrieving the length of the vars array. Next I 
allocate a new function frame that takes a new array of Formals (since the function
will take no parameters) and the local environment object globals. 

    The vars array is defined as an array of VarIntros, however the initialized globals
will actually be instances of InitVarIntros. The difference between the two is that 
InitVarIntros possess an expression field (representing the initialization) while VarIntros
do not. Therefore, I could not directly access the expression field due to the fact that
some objects may not contain this field. As a result, I needed to getExp methods in both
classes. The one in InitVarInro returns the expression, the one in VarIntro returns null.

    /** Return the initialization expression
     *  This method is in the InitVarIntro class within ast/InitVarIntro.java
     */
    public Expr getExpr() { return exp; }

    /** Return null since the is no initializing expression
     *  This method is in the VarIntro class within ast/VarIntro.java
     */
    public Expr getExpr() { return null; }


    A side effect of this choice was that I retrieve the expression, and then test whether the
reference was null or not. This wasn't entirely nessecary because an error gets generated
during the parsing phase if a global is not initialized. However, it felt much safer to
do so, instead of running the risk of a dereferencing a null pointer.

    Finally, the returned expression gets compiled, and the value gets stored in the function
frame. 

    /** Generate compiled code for the initGlobals function that retrieves 
     *  and compiles the expression value from each global variable declaration
     *  and stores those values in a global function frame.
     *  This method is in the Globals class within ast/Globals.java
     */ 
    void compileGlobals(Assembly a, LocEnv globals) {
        int length = vars.length;
        Frame f = new FunctionFrame( new Formal[0], globals);
        Expr e;
        //Loop through the array of VarIntros 
        for(int i = 0; i < length; ++i) {
            // Retrieve the indexed expression from the array of variables
            e = vars[i].getExpr();
            if(e != null) {
                // compile the retrieved expression
                e.compileExpr(a,f);
                // Store the value  
                f.store32(a, vars[i].name);
            }  
        }
       
    }

    To test my code generation scheme, I again created a program. For testing I initialized with
integer, multiplication, subtraction, unary minus, and addition expressions. I also used previously
defined globals within the expressions to initialize the values of others. All of which sucessfully
printed their initial values. I then created a nested scope variable with the same name as a global,
and it sucessfully printed the nested scope value. I then tried altering the values of the global
variables, these also printed the correct altered values.

There were a few things that I tried that did not work. This was only due to the fact that division
had not been implemented yet, and a few errors that were generated during static analysis. Therefore,
the things that did not work, were working correctly in terms of the compiler.
    
    //Test program for question #2
    int a = 4;
    int b = 4 * 3;
    int c = a - b;
    int d = -c;
    //int e = d / c;         <--- Div not yet implemented
    //int f = a < b;         <--- Threw an error during static analysis "InitVarEntryType"
    //int g;                 <--- Threw an error during static analysis "GloblasInitialized"
    int h = -(a + b - c * d); 

    void main() {            //--Expected output-- | --Actual Output--//
        print a;             //         4          |         4        //
        print b;             //         12         |         12       // 
        print c;             //         -8         |         -8       //
        print d;             //         8          |         8        //
        print h;             //        -80         |        -80       // 
                             //                    |                  //
        if(b > a) {          //                    |                  //
            int b = 42;      //                    |                  //
            print b;         //         42         |         42       //
        }                    //                    |                  //
                             //                    |                  //
        print b;             //         12         |         12       //
        a = a + 1;           //                    |                  //
        b = b * c;           //                    |                  //
        print a;             //         5          |         5        //
        print b;             //         -96        |         -96      //
    }

    I also looked at the generated assembly in out.s to see if the initGlobals function had been
generated as I had anticipated.

              
              .
              .                  <--- ommited for brevity
              .
    Xd:
	    .long	0
    Xh:
	    .long	0                <--- Global declarations

        .text                    

        .globl	XinitGlobals     <--- function definition first within .text region
    XinitGlobals:
        pushq	%rbp             ---+
        movq	%rsp, %rbp       <--- prologue
        movl	$4, %eax         ---+
        movl	%eax, Xa         <--- a = 4
        movl	$4, %eax         ---+
        movl	$3, %edi            |
        imull	%edi, %eax          |
        movl	%eax, Xb         <--- b = 3 * 4
        movl	Xa, %eax         ---+
        movl	Xb, %edi            |
        subl	%edi, %eax          |
        movl	%eax, Xc            |
        movl	Xc, %eax         <--- c = a - b
        negl	%eax             ---+
        movl	%eax, Xd         <--- d = -c
        movl	Xa, %eax         ---+
        movl	Xb, %edi            |
        addl	%edi, %eax          |
        movl	Xc, %edi            |
        movl	Xd, %esi            |
        imull	%esi, %edi          |
        subl	%edi, %eax          |
        negl	%eax                |
        movl	%eax, Xh         <--- h = -(a+ b - c * d)
        movq	%rbp, %rsp       ---+
        popq	%rbp             <--- epilogue
        ret

        .globl	Xmain
    Xmain:
        pushq	%rbp
        movq	%rsp, %rbp
              .
              .
              .
              
3) Reverse Engineering Source Code
-------------------------------------------------------------------------------------
    // This is my interpretation of the original source code. 
    // I am still unsure as to the meaningful semantics (if there are any) of the
    // program as a whole.
    void main () {
        int a = 1;
        int b = 2;
        int c = 2;

        while(a < 10) {
           int z = 0; 
           while( z < a ){
             b = f(b, z);
             print h(g(z));
             z = 1 + z;  
           }
           print b;
           b = b * c;
           a = a + 1;
        }
        print a;
    }
    // Returns a squared value of the difference of the first and second argument
    int f (int x, int y) {
       int n = x - y;
       n = n * g(n);
       return n;
    }
    // Returns the same value as was supplied
    int g(int x) {
       return 2 * x - x;
    }
    // Fibbonacci sequence
    int h(int x) {
       if( x < 2) {
           return 1;
       } else {
           return h(x-1) + h(x-2);
       }
    }


    # These are my annotations of the provided assembly
        .file	"out.s"

        .data

        .text
        .globl	Xmain
    Xmain:
        pushq	%rbp               # prologue
        movq	%rsp, %rbp
        movl	$1, %eax           # 1st Local variable = 1
        pushq	%rax
        movl	$2, %eax           # 2nd Local variable = 2
        pushq	%rax
        movl	$2, %eax           # 3rd Local variable = 2
        pushq	%rax
        jmp	l1
    l0:
        movl	$0, %eax           # 4th Local variable = 0
        pushq	%rax
        jmp	l3
    l2:
        movl	-16(%rbp), %edi   	
        movl	-32(%rbp), %esi
        call	Xf                 # 2nd = f(2nd, 4th)
        movl	%eax, -16(%rbp)
        movl	-32(%rbp), %edi    # return value of nested function calls h(g(4th))
        call	Xg                 # |
        movq	%rax, %rdi         # |
        call	Xh                 # V
        movq	%rax, %rdi         # becomes arg for print
        call	Xprint
        movl	$1, %eax
        movl	-32(%rbp), %edi    
        addl	%edi, %eax         # Increment 4th by one
        movl	%eax, -32(%rbp)    # Store sum back in 4th 
    l3:
        movl	-8(%rbp), %eax
        movl	-32(%rbp), %edi
        cmpl	%eax, %edi         # While conditional 4th < 1st
        jl	l2                     
        movl	-16(%rbp), %edi    # 2nd local var becomes arg for print
        call	Xprint
        movl	-16(%rbp), %eax
        movl	-24(%rbp), %edi
        imull	%edi, %eax         # Multiply 3rd and 2nd
        movl	%eax, -16(%rbp)    # Store product back in 2nd
        movl	-8(%rbp), %eax     
        movl	$1, %edi
        addl	%edi, %eax         # Increment 1st by one
        movl	%eax, -8(%rbp)     # Store sum back in 1st
        addq	$8, %rsp           # 4th local no longer in scope
    l1:
        movl	$10, %eax
        movl	-8(%rbp), %edi
        cmpl	%eax, %edi         # While conditional 1st < $10
        jl	l0                       
        movl	-8(%rbp), %edi     # 1st local becomes arg for print     
        call	Xprint     
        movq	%rbp, %rsp         # epilogue
        popq	%rbp
        ret

        .globl	Xf                 # Function
    Xf:
        pushq	%rbp               # Prologue
        movq	%rsp, %rbp
        movl	%edi, %eax
        movl	%esi, %ecx
        subl	%ecx, %eax
        pushq	%rax
        movl	-8(%rbp), %eax     # localF initialized to difference of first and second arg
        pushq	%rax
        pushq	%rsi
        pushq	%rdi
        movl	-8(%rbp), %edi     # return of g(localF)
        call	Xg                 # |
        movq	%rax, %rcx         # |
        popq	%rdi               # |
        popq	%rsi               # |
        popq	%rax               # V
        imull	%ecx, %eax         # Multiplied with localF
        movl	%eax, -8(%rbp)     # Stored back in localF
        movl	-8(%rbp), %eax     # Return localF
        movq	%rbp, %rsp
        popq	%rbp               # Epilogue
        ret

        .globl	Xg                 # Function
    Xg:
        pushq	%rbp               # Prologue
        movq	%rsp, %rbp      
        movl	$2, %eax           # Load constant into register ***** Dont need to do this! *****
        movl	%edi, %esi
        imull	%esi, %eax         # Multiply argument by two
        movl	%edi, %esi
        subl	%esi, %eax         # subract product by value of argument
        movq	%rbp, %rsp
        popq	%rbp               # Epilogue
        ret

        .globl	Xh                 # Function
    Xh:
        pushq	%rbp               # Prologue
        movq	%rsp, %rbp         
        movl	$2, %eax           # Load constant into register ***** Dont need to do this! *****
        movl	%edi, %esi 
        cmpl	%eax, %esi         # if arg > 2 jump
        jnl	l4                    
        movl	$1, %eax           # otw, return 1
        movq	%rbp, %rsp
        popq	%rbp               # Epilogue
        ret
    l4:
        pushq	%rdi
        movl	-8(%rbp), %edi     # h(arg - 1)
        movl	$1, %esi           # |
        subl	%esi, %edi         # |
        call	Xh                 # | Recursion
        popq	%rdi               # |
        pushq	%rax               # |
        pushq	%rdi               # V
        movl	-16(%rbp), %edi    # h(arg - 2)
        movl	$2, %esi           # |
        subl	%esi, %edi         # |
        call	Xh                 # | Recursion
        movq	%rax, %rsi         # |
        popq	%rdi               # |
        popq	%rax               # V
        addl	%esi, %eax         # Return the sum of the return values of the recursive calls
        movq	%rbp, %rsp
        popq	%rbp               # Epilogue
        ret

    One way that the source program could have differed from my reverse engineered copy
could be the variable names. In assembly there are no references to local variable names
so the names that were initially used could very well be wildly different than the (admittedly
non creative) ones that I came up with. Also any difference in whitespace or comments between
the original and reconstructed code could never be determined by only analyzing the machine
generated assembly.

    There were a few places in the generated code that loaded constant values into a register
before using that register to evaluate and expression. This could have been done by directly
using the constant value rather than loading it into a register before hand.

    There were places where the code was incrementing the value of a variable,
but instead of using the 'incl' instruction it would load the constant '1' into a register,
then load the value of a local variable into another register and perform an 'addl'. This
would could be improved by two instructions if you simply did 'incl -8(%rsp)' for instance.

    In the function g(), the argument gets multiplied by a constant value of two. Multiplication
is a complex instruction that takes more time than many others. Since 2 is a power of 2 (obviously),
the same effect could be achieved by arithmetically shifting the value of the argument to the 
left once. 

I made patches in the assembly file to reflect these optimizations. When executing this code the
output was identical to the output of the original assmebly. Here is a diff of the original 
assembly and the patched version.

    56,58c56,57
    <   #movl   $1, %edi
    <   #addl   %edi, %eax
    <     incl    %eax
    ---
    >   movl    $1, %edi
    >   addl    %edi, %eax
    62c61
    <     #movl    $10, %eax
    ---
    >   movl    $10, %eax
    64,65c63
    <     #cmpl    %eax,  %edi
    <   cmpl    $10, %edi
    ---
    >   cmpl    %eax, %edi
    102,106c100,102
    <   #movl   $2, %eax
    <   #movl   %edi, %esi
    <   #imull  %esi, %eax
    <     movl    %edi, %eax
    <     sal     $1,   %eax
    ---
    >   movl    $2, %eax
    >   movl    %edi, %esi
    >   imull   %esi, %eax

