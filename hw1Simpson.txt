Name: Michael Simpson
Date: 04-11-15
Course: CS322
Instructor: Jones
Assignment: #1


1) Modify the DemoComp compiler to support the following constructs

    ***** All work was done in the C directory of DemoComp*****

    -Multiplication
        
        I began by adding a 'Mult' class in Src.java that extends the 'IExpr' class.
        This class closely follows the pattern of the other 'IExpr' subclasses with only
        minor modifications made to reflect a multiplication operation where nessecary. 
            //Added to Src.java 
            class Mult extends IExpr {
              private IExpr l, r;
              Mult(IExpr l, IExpr r) { this.l = l; this.r = r; }
              
              /**
               * multiply the return values of eval as called from the left and
               * right operands and return the result of the operation
               */
              int    eval(Memory mem) { return l.eval(mem) * r.eval(mem); }
              
              /**
               * print the operation as multiplication show with an asterisk
               */
              String show() { return "(" + l.show() + " * " + r.show() + ")"; }
              
              /**
               * Construct stack frame of multiplication operator
               * to compile source code into target representation 
               */  
              Code compileTo(Reg reg, Code next) {
                Reg tmp = new Reg();
                return l.compileTo(tmp,
                       r.compileTo(reg,
                       new Op(reg, tmp, '*', reg, next)));
              }
            }   

        I also modified the method  "run" inside the Op class within Target.java 
        to include a case for the added  multiplication operator. This adds a new 
        instruction to the "assembly" that will evaluate multiplication operation
        and allow the translated expression to be evaluated in the target language.
  
            //Added to Target.java, Op class, within "run" method
            case '*' : r.set(x.get() * y.get());
                       break;
 
        These changes were sufficient for being able to implement a multiplication construct
        for the DemoComp complier. To test that my alterations were correct, I went into 
        Main.java and created a new function. This function contained a copy of the ast and 
        copmilation code that was already present in this file. I altered the abstact syntax
        tree to perform a Mult operation and also altered a few other values.

            /**
             * An AST that I used for testing
             */
            Stmt s
               = new Seq(new Assign("t", new Int(1)),
                 new Seq(new Assign("i", new Int(1)),
                 new Seq(new While(new LT(new Var("i"), new Int(5)),
                                   new Seq(new Assign("t", new Mult(new Var("t"), new Var("i"))),
                                           new Assign("i", new Plus(new Var("i"), new Int(1))))),
                         new Print(new Var("t")))));

        This test calculates four factorial. The result of this program correctly printed 
        the value 24 as the output of source and target evaluation. I also played around with 
        changing the AST to ensure the correctness of my code, and the values continued to
        print as expected.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    -Not

        This case was somewhat more involved than multiplication, mainly because there were
        no unary boolean expressions from which I could base a pattern. The only major difference
        was in the compile to method where null gets passed in as the second argument, the rest
        was fairly similar.

            //Added to Src.java 
            class Not extends BExpr {
                private BExpr e;
                Not(BExpr e) { this.e = e; }
                
                /**
                 * negate the return value of eval method
                 */
                boolean eval(Memory mem) { return !e.eval(mem); }
                /**
                 * display the not construct as a function call
                 */
                String show() { return "not (" + e.show() + ")"; }
                /**
                 * call compileTo method passing in null for second arg since
                 * not is a unary operator
                 */
                Code compileTo(Reg reg, Code next) {
                    return e.compileTo(reg, new Op(reg, null, '!', reg, next));
                }
            }

        Again this construct also needed an addition to the target code Op class so that
        the instructions could be translated during compilation. Since there only one 
        register in action it loads the bool value, negates that value, and then stores
        the updated value back to the same register.

            //Added to Target.java, Op class, witin "run" method
            case '!' : r.setBool( !y.getBool() );
                       break;
   
        This next part wasn't strictly necessary, but it made sense to add a Bool non
        terminal to the grammar so I went ahead and did so. It stores an integer flag,
        evaluates, prints, and compiles boolean values based upon the integer value.

            //Added to Src.java
            class Bool extends BExpr {
                private int flag;
                Bool(int flag) { this.flag = flag; }
               
                /**
                 * Zero value evaluates to false, any other value evaluates to true
                 */ 
                boolean eval(Memory mem) { 
                   if( 0 == flag) {
                      return false;
                  }
                  return true;
                }
                
                /**
                 * Zero value prints false, any other value prints true
                 */  
                String show() { 
                  if( 0 == flag) {
                      return "false";
                  }
                  return "true";
                }
                
                 /**
                 * assigns the flag value to a register
                 */ 
                Code compileTo(Reg reg, Code next) {
                  return new Immed(reg, flag, next);
                }
           }

        To test the not construct I did as before and created some AST structures that I
        could then run and inspect the source and target evaluations. This test simply reads,
        if(not(true)){ print 0;} else {print 42;}. Upon running the code, it correctly prints 
        the value 42 both through source and target evaluation.

            //An AST to test the Not construct
                Stmt s
                    = new If(new Not( new Bool(1)),
                      new Print(new Int(0)),
                      new Print(new Int(42)));
 

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    -LTE

        I actually left this case for last. It seemed like it would be trivial if just 
        extended the target language, but it took me a bit of experimenting with the 
        other constructs before a solution became more clear. Instead of adding any
        new instruction to the target, I instead recycled the subtraction and eqeq 
        operators.

            //Added to Src.java
            class LTE extends BExpr {
              private IExpr l, r;
              LTE(IExpr l, IExpr r) { this.l = l; this.r = r; }

              /**
               * evaluating the expression in the source language
               */
              boolean eval(Memory mem) { return l.eval(mem) <= r.eval(mem); }
              /**
               * printing the expression as a binary operator
               */
              String show()  { return "(" + l.show() + " <= " + r.show() + ")"; }

              /**
               * Recycling existing target instructions to emulate the behavior
               * of a less than or equal operator
               */
              Code compileTo(Reg reg, Code next) {
                Reg temp = new Reg();
                Reg mid = new Reg();
                return l.compileTo(reg,
                       r.compileTo(temp,
                           new Op(mid, reg, '-', temp, 
                           new Immed(temp, 1,
                               new Op(reg, mid, '<', temp, next)))));
             }
            }

        Since I did not extend the target language, I did not make any modifications to 
        Target.java. I did however do some testing. Here is an example AST that correctly
        prints output of 0 from both source and target evaluation.

             Stmt s
                = new If(new Not( new LTE(new Int(3), new Int(2))),
                         new Print(new Int(0)),
                         new Print(new Int(42)));
          
   
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
    -Even
        
        Creating the even construct took me a few tries to get right. I had a
        few other solutions that worked, but this seemed like the most correct
        solution to me. Eval and display were fairly self explanitory, but 
        getting the compile to method to how it is here took a good amount 
        of inspection into exactly how the target language really works.

            class Even extends BExpr {
                private IExpr v;
                Even(IExpr v) { this.v = v; }
                
                /**
                 * checking if the value of v is even with mod operator
                 */
                boolean eval(Memory mem) { 
                    if( 0 == v.eval(mem) % 2 ) {
                        return true;
                    }
                    return false;
                }

                /**
                 * display the not construct as a function call
                 */
                String show() { return "even (" + v.show() + ")"; }

                /**
                 * call compileTo method passing in abstract syntax
                 * structure of target language
                 */
                Code compileTo(Reg reg, Code next) {
                    Reg lit = new Reg();
                    Reg temp = new Reg();

                    return v.compileTo(reg,
                                       new Immed(lit, 2, 
                                       new Op(reg, reg, '%', lit, 
                                           new Immed(lit, 0,
                                           new Op(reg, reg, '=', lit, next))))); 
                }
            }

        The only thing I added to the target language was a mod operator instruction.
        This seemed like the cleanest solution to the problem that required the least
        addition to either language.
            
            //Addded to Op class, "run" method, in Target.java
            case '%' : r.set( x.get() % y.get() );
                       break;    

        This is an example AST that I used for testing, which correctly prints the value
        '128' as a result of both source and target evaluation.

            Stmt s
               = new If(new Even(new Int(2)),
                        new Print(new Int(128)),
                        new Print(new Int(256)));
 
     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
    -Half

        The Half construct was dead easy after putting the time into Even. Much of the
        pattern was the same as Even, and in fact it is more simplified. I suppose the
        biggest difference is that Half is a subclass of IExpr rather than BExpr.
            
            //Added to Src.java
            class Half extends IExpr {
                private IExpr p;
                Half(IExpr p) { this.p = p; }
                
                /**
                 * halving the return value of p.eval
                 */
                int eval(Memory mem) { 
                   return p.eval(mem) / 2;
                }
                /**
                 * display the half construct as a function call
                 */
                String show() { return "half (" + p.show() + ")"; }
                /**
                 * call compileTo method passing in abstract syntax
                 * structure of target language
                 */
                Code compileTo(Reg reg, Code next) {
                    Reg lit = new Reg();

                    return p.compileTo(reg,
                                       new Immed(lit, 2, 
                                       new Op(reg, reg, '/', lit, next)));
                }
            }
       
        Again, I added an instruction to the target language to support this
        functionality.
            
            //Added to Op class, "run" method, within Target.java
            case '/' : r.set( x.get() / y.get() );
                       break;

        I have been getting more creative with my testing (or at least more lengthy).
        Here is an example AST that I used to test the Half construct. It doesn't do
        anything extremely interesting, but it does correctly print the values 3, 2,
        and 1 as a result of both source and target evaluation.

            Stmt s
               = new Seq(new Assign("i", new Int(3)),
                 new Seq(new Assign("k", new Int(20)),
                 new While( new LT(new Int(4), new Var("k")),
                            new Seq(new Assign("k", new Half(new Var("k"))),
                            new Seq(new Assign("i", new Minus(new Var("i"), new Int(1))),
                                    new Print(new Var("i")))))));

################################################################################

2) Program Structure

        ***********************************************************
        ***** Abstract Syntax Tree Attached to Seperate Sheet *****
        ***********************************************************

        -Code
            class Main {
              public static void main(String[] args) {
                Stmt s = q2();

                System.out.println("Complete program is:");
                s.print(4);

                System.out.println("Running on an empty memory:");
                Memory mem = new Memory();
                s.exec(mem);

                System.out.println("Compiling:");
                Program p     = new Program();
                Block   entry = p.block(s.compile(p, new Stop()));
                System.out.println("Entry point is at " + entry);
                p.show();

                System.out.println("Running on an empty memory:");
                mem      = new Memory();
                Block pc = entry;
                while (pc!=null)  {
                  pc = pc.code().run(mem);
                } 

                System.out.println("Done!");
              }

              public static Stmt q2() {
                Stmt s
                   = new Seq( new Assign("t", new Int(0)),
                     new Seq( new Assign("x", new Int(6)),
                     new Seq( new Assign("y", new Int(7)),
                     new Seq( new While( new LT( new Int(0), new Var("x")),
                              new Seq( new If( new Not( new Even( new Var("x"))),
                                       new Assign( "t", new Plus( new Var("t"), new Var("y"))),
                                       new Assign( "t", new Var("t"))),
                              new Seq( new Assign( "y", new Plus( new Var("y"), new Var("y"))),
                              new Assign( "x", new  Half( new Var( "x")))))),
                     new Print( new Var("t"))))));
                return s;          
              }
            }

        The algorithm expressed by the AST multiplies x and y.

################################################################################

3) Optimization Observations

        After analyzing the target language output from the program that was constructed
        in question #2, the first glaring optimization was inefficientregister use.  
        It may not have been too bad for this particular example (though I am positive 
        the algorithm could have executed properly using less than 16 registers), but
        for programs of a larger scale the register usage would be astronomical.
        Resgisters are extremely fast memory storage locations on the CPU. However,
        this quick access comes at a high monitary cost in comparison to memory
        lower down the hierarchy. Optimizing register usage in this instance would
        be an example of space optimization.

        Another thing that I noticed was that when an assign operation instruction gets
        executed the result of the operation gets stored in a register, which then 
        gets stored into the memory location of the variable being assigned to. 
        If the result of the operation just directly got stored into the variables 
        memory location, it could reduce the cost of assignment by one instruction.

        

        
